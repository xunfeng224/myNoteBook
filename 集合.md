# 集合

![src=http___yqfile.alicdn.com_img_a74d00b5f19c2ad3616c1d04e7a6b20e.png&refer=http___yqfile.alicdn](src=http___yqfile.alicdn.com_img_a74d00b5f19c2ad3616c1d04e7a6b20e.png&refer=http___yqfile.alicdn.webp)

## 一、集合的理解和好处

### 数组

1. 长度开始时必须指定，而且一旦指定，不能更改
2. 保存的必须为同一类型的元素
3. 使用数组进行增加/删除元素 比较麻烦

### 集合

1. 可以动态保存任意多个对象，使用比较方便
2. 提供了一系列方便的操作对象的方法：add,remove,set,get等
3. 使用集合添加删除新元素简洁



## 二、集合的框架体系

**Collection**

![image-20220122175613327](https://s2.loli.net/2022/05/09/Nhtn1AcxVO7pfrk.png)

**Map**

![image-20220122180220136](https://s2.loli.net/2022/05/09/9s1UlbB8ApmtvFJ.png)



1. 集合主要是两组(单列集合 , 双列集合)
2. Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列
3. Map 接口的实现子类 是双列集合，存放的 K-V

## 三、Collection 接口和常用方法

### Collection 接口实现类的特点

```java
public interface Collection<E> extends Iterable<E>
```

1. collection实现子类可以存放多个元素，每个元素可以是Object
2. 有些Collection的实现类，可以存放重复的元素，有些不可以，后边细说
3. 有些Collection的实现类，有些是有序的（List），有些是无序的（Set）
4. Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的

### Collection 接口常用方法

```java
package collection;

import java.util.ArrayList;
import java.util.List;

/**
 * @program: study
 * @description: Collection常用方法
 * @author: xiongfeng
 * @create: 2022-01-22 18:11
 **/
public class CollectionMethod {
    public static void main(String[] args) {
        //以其实现子类 ArrayList 来演示
        //1.add 添加单个元素
        List list = new ArrayList();
        list.add("jack");
        list.add(10);
        list.add(true);
        System.out.println("list=" + list);
        //2.remove 删除指定元素,按照索引删除或者删除指定对象
        list.remove(1);//返回值为boolean
        list.remove("jack");//返回值为Object ，被删除的对象
        System.out.println("list=" + list);
        //3.contains 查找元素是否存在
        System.out.println(list.contains("jack"));
        //4.size 获取元素个数
        System.out.println(list.size());
        //5.isEmpty 判断是否为空
        System.out.println(list.isEmpty());
        //6.clear 清空
        //list.clear();
        //System.out.println("list="+list);

        //7.addAll 添加多个元素
        ArrayList list2 = new ArrayList();
        list2.add("java核心技术卷");
        list2.add("数据结构与算法");
        list.addAll(list2);
        System.out.println("list=" + list);
        //8.containsAll 查找多个元素是否存在
        System.out.println(list.containsAll(list2));
        //9.removeAll 删除多个元素
        list.add("深入理解java虚拟机");
        list.removeAll(list2);
        System.out.println("list=" + list);

    }
}
```



### Collection 接口遍历元素方式 1-使用 Iterator(迭代器)

**介绍**

1）Iterator对象称为迭代器，主要用于遍历 Collection 集合中的元素。

2）所有实现了Collection接口的集合类都有一个iterator（）方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。

3）Iterator的结构．

4）Iterator 仅用于遍历集合，Iterator 本身并不存放对象。 

**Iterator接口的方法**

![image-20220122185124371](https://s2.loli.net/2022/05/09/5TjryWHBYDQOfG6.png)

**基本语法**

```java
//先获取Collection对象的Iterator迭代器
Iterator iterator = collection01.iterator();
//必须判断是否有下一个元素
while(iterator.hasNext()) {
    //iterator.next();迭代器下移，并将下一以后集合位置上的元素返回
    Object obj = iterator.next();
    访问元素obj
}
```



```java
package collection;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * @program: study
 * @description: 迭代器
 * @author: xiongfeng
 * @create: 2022-01-22 18:52
 **/
public class Iterator01 {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("jack");
        list.add(10);
        list.add(true);
        //1. 先得到 集合 对应的 迭代器
        Iterator<Object> objectIterator = list.iterator();
        //2. 使用 while 循环遍历
        //注意，在调用objectIterator.next()方法之前必须要调用objectIterator.hasNext()判断是否还有下一个元素。若不调用，且下一条记录无效，直接调用objectIterator.next()会抛出NoSuchElementException异常
        while (objectIterator.hasNext()) {//判断是否还有数据
            //返回下一个元素，类型是 Object
            Object obj = objectIterator.next();
            System.out.println("obj=" + obj);
        }
        //3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素
        // iterator.next();//NoSuchElementException
        //4. 如果希望再次遍历，需要重置我们的迭代器
        objectIterator = list.iterator();
        System.out.println("===第二次遍历===");
        while (objectIterator.hasNext()) {
            Object obj = objectIterator.next();
            System.out.println("obj=" + obj);
        }
        
        //IDEA快捷键生成 itit，查看所有快捷键ctrl+j
//        while (objectIterator.hasNext()) {
//            Object next =  objectIterator.next();
//
//        }

    }
}
```

### Collection 接口遍历对象方式 2-for 循环增强

**介绍**

增强for循环可以代替iterator迭代器，特点：增强for就是简化版的iterator，**本质是一样的**。可以用于遍历集合或数组。

**基本语法**

```java
for(元素类型 元素名 : 集合名或数组名) {
    访问元素
}
//IDEA快捷方式 大写I
```

## 四、List 接口和常用方法

### List 接口基本介绍

1. List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复
2. List 集合中的每个元素都有其对应的顺序索引，即支持索引
3. JDK API中List接口的实现类如下图，常用的有ArrayList，LinkedList和Vector

![image-20220122191916853](https://s2.loli.net/2022/05/09/kW1cuSI76xAQaTB.png)

### **List常用方法**

```java
package collection;

import java.util.ArrayList;
import java.util.List;

/**
 * @program: study
 * @description: List常用方法
 * @author: xiongfeng
 * @create: 2022-01-22 20:58
 **/
public class ListMethod {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("张三丰");
        list.add("贾宝玉");
        // void add(int index, Object ele):在 index 位置插入 ele 元素
        //在 index = 1 的位置插入一个对象
        list.add(1, "韩顺平");
        System.out.println("list=" + list);
        // boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来
        List list2 = new ArrayList();
        list2.add("jack");
        list2.add("tom");
        list.addAll(1, list2);
        System.out.println("list=" + list);
        // Object get(int index):获取指定 index 位置的元素
        System.out.println(list.get(0));
        // int indexOf(Object obj):返回 obj 在集合中首次出现的位置
        System.out.println(list.indexOf("tom"));//2
        // int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置
        list.add("曹操");
        System.out.println("list=" + list);
        System.out.println(list.lastIndexOf("曹操"));
        // Object remove(int index):移除指定 index 位置的元素，并返回此元素
        list.remove(0);
        System.out.println("list=" + list);
        // Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, "玛丽");
        System.out.println("list=" + list);
        // List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合
        // 注意返回的子集合 fromIndex <= subList < toIndex
        List returnlist = list.subList(0, 2);
        System.out.println("returnlist=" + returnlist);
    }
}
```

## 五、List接口实现类ArrayList

### 注意事项

1. permits all elements,including null，ArrayList可以加入null，并且允许多个
2. ArrayList是由数组来实现数据存储的
3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程的情况下，不建议使用ArrayList

### 底层结构和源码

1. ArrayList中维护了一个Object类型的数组elementData
   transient Object[] elementData
   transient 美[ˈtrænʃnt] 短暂的     将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。
2. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elemetData容量为0，第一次添加，则扩容elementDate为10，如需要再次扩容，则扩容element为原来的1.5倍
3. 如果使用的是指定大小的构造器，则初始的elementData大小为指定大小，当需要扩容时，则直接扩容elementDate为1.5倍

```java
import java.util.ArrayList;

public class ArrayListSource {
    public static void main(String[] args) {
        //使用debug查看源码，及扩容过程
        //注意，注意，注意，Idea 默认情况下，Debug 显示的数据是简化后的，如果希望看到完整的数据
        //需要做在Debug设置中取消勾选Enable alternative view for Collection classes. 
        //使用无参构造器创建 ArrayList 对象
        //ArrayList list = new ArrayList();
        ArrayList list = new ArrayList(8);
        //使用 for 给 list 集合添加 1-10 数据
        for (int i; i <= 10; i++) {
            list.add(i);
        }
        //使用 for 给 list 集合添加 11-15 数
        for (int i = 11; i <= 15; i++) {
            list.add(i);
        }
        list.add(100);
        list.add(200);
        list.add(null);
    }
}
```

![image-20220227103354047](https://s2.loli.net/2022/05/09/wrbNFc4nDVXeAYO.png)

![image-20220227103502778](https://s2.loli.net/2022/05/09/M8yhfIDWLbFP5ta.png)



## 六、List接口实现类Vector

### 基本介绍

1. Vector类的定义说明

   ```java
   Public class Vector<E>
   extends AbstracList<E>
   implements List<E>,RandomAccess,Cloneable,Serializable
   ```

2. Vector底层也是一个对象数组  protected Object[] elementData

3. Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized

4. 在开发中，需要线程同步安全时，考虑使用Vector

```java
package collection;

import java.util.Vector;

public class Vector_ {
    public static void main(String[] args) {
        //无参构造器
        Vector vector1 = new Vector();
        //有参数的构造
        Vector vector = new Vector(8);
        for (int i = 0; i < 10; i++) {
            vector.add(i);
        }
        vector.add(100);
        System.out.println("vector=" + vector);
        
    /*
    //1. new Vector() 底层
    public Vector() {
    	this(10);
    }
    补充：如果是 Vector vector = new Vector(8);
    走的方法:
    public Vector(int initialCapacity) {
    	this(initialCapacity, 0);
    }
    2. vector.add(i)
    2.1 //下面这个方法就添加数据到 vector 集合
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
    2.2 //确定是否需要扩容 条件 ： minCapacity - elementData.length>0
    private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
        	grow(minCapacity);
    }
    2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法
    //这里的capacityIncrement是另外一个需要指定扩容大小的构造器所需的参数，默认为0，即默认扩容两倍
    //newCapacity = oldCapacity + ((capacityIncrement > 0) ?
    // 								capacityIncrement : oldCapacity);
    //就是扩容两倍.
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
        								capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity < 0)
        	newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
        	newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
*/
    }
}
```



### Vector和ArrayList的比较

|           | 底层结构 | 版本   | 线程安全（同步）效率 | 扩容倍数                                                     |
| --------- | -------- | ------ | -------------------- | ------------------------------------------------------------ |
| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高       | 如果有参构造1.5倍，如果是无参 1.第一次10  2.第二次开始按1.5倍扩容 |
| Vector    | 可变数组 | jdk1.0 | 安全，效率不高       | 如果有参构造2倍，如果是无参 1.第一次10  2.第二次开始按2倍扩容  注意：可以自定义每次扩容大小capacityIncrement |

## 七、List接口实现类LinkedList

### 基本介绍

1. LinkedList底层实现了**双向链表**和**双端队列**的特点
2. 可以添加任意元素（元素可以重复），包括null
3. 线程不安全，没有实现同步

### LinkedList底层操作机制

1. LinkedList底层维护了一个双向链表
2. LinkedList中维护了两个属性first和last分别指向 首节点和尾节点
3. 每个结点（Node对象),里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个结点。最终实现双向链表
4. 所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高

```java
package collection;

import java.util.Iterator;
import java.util.LinkedList;

public class LinkedListCRUD {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        System.out.println("linkedList=" + linkedList);
        //演示一个删除结点的
        linkedList.remove(); // 这里默认删除的是第一个结点
        //linkedList.remove(2);
        System.out.println("linkedList=" + linkedList);
        //修改某个结点对象
        linkedList.set(1, 999);
        System.out.println("linkedList=" + linkedList);
        //得到某个结点对象
        //get(1) 是得到双向链表的第二个对象
        Object o = linkedList.get(1);
        System.out.println(o);//999
        //因为 LinkedList 是 实现了 List 接口, 遍历方式
        System.out.println("===LinkeList 遍历迭代器====");
        Iterator iterator = linkedList.iterator();
        while (iterator.hasNext()) {
            Object next = iterator.next();
            System.out.println("next=" + next);
        }
        System.out.println("===LinkeList 遍历增强 for====");
        for (Object o1 : linkedList) {
            System.out.println("o1=" + o1);
        }
        System.out.println("===LinkeList 遍历普通 for====");
        for (int i = 0; i < linkedList.size(); i++) {
            System.out.println(linkedList.get(i));
        }
        /* 1. LinkedList linkedList = new LinkedList();
        public LinkedList() {}
        2. 这时linkeList 的属性 first = null last = nul
        3. 执行 添加
            public boolean add(E e) {
                linkLast(e);
                return true;
            }
        4.将新的结点，加入到双向链表的最后
            void linkLast(E e) {
                final Node<E> l = last;
                final Node<E> newNode = new Node<>(l, e, null);
                last = newNode;
                if (l == null)
                    first = newNode;
                else
                    l.next = newNode;
                size++;
                modCount++;
            }
        */
        /*
         linkedList.remove(); // 这里默认删除的是第一个结点
        1. 执行 removeFirst
            public E remove() {
                return removeFirst();
            }
        2. 执行
            public E removeFirst() {
                final Node<E> f = first;
                if (f == null)
                    throw new NoSuchElementException();
                return unlinkFirst(f);
            }
        3. 执行 unlinkFirst, 将 f 指向的双向链表的第一个结点拿掉
            private E unlinkFirst(Node<E> f) {
                // assert f == first && f != null;
                final E element = f.item;
                final Node<E> next = f.next;
                f.item = null;
                f.next = null; // help GC
                first = next;
                if (next == null)
                    last = null;
                else
                    next.prev = null;
                size--;
                modCount++;
                return element;
            }
        */
    }
}
```

## 八、ArrayList和LinkedList比较

|            | 底层结构 | 增删的效率        | 改查的效率 |
| ---------- | -------- | ----------------- | ---------- |
| ArrayList  | 可变数组 | 较低 数组扩容     | 较高       |
| LinkedList | 双向链表 | 较高 通过链表追加 | 较低       |

如何选择：

1. 如果改查的操作多，选择ArrayList
2. 如果增删的操作多，选择LinkedList
3. 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList
4. 在一个项目中，根据业务灵活选择，也可以一个模块使用ArrayList，另外一个模块是LinkedList

## 九、Set接口和常用方法

### 基本介绍

1. 无序（添加和取出的顺序不一致），没有索引
2. 不允许重复元素，所以最多包含一个null
3. JDK API中Set接口的实现类有

### Set接口常用方法

和List接口相同，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样

### Set接口的遍历方式

同Collection的遍历方式一样，因为Set接口是Collection接口的子接口

1. 可以使用迭代器
2. 增强for循环
3. **不能使用索引的方式来获取**

### Set接口常用方法举例

```java
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class SetMethod {
    public static void main(String[] args) {
        //1. 以 Set 接口的实现类 HashSet 来讲解 Set 接口的方法
        //2. set 接口的实现类的对象(Set 接口对象), 不能存放重复的元素, 可以添加一个 null
        //3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)
        //4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是取出的顺序是固定的. 
        Set set = new HashSet();
        set.add("john");
        set.add("lucy");
        set.add("john");//重复
        set.add("jack");
        set.add("hsp");
        set.add("mary");
        set.add(null);//
        set.add(null);//再次添加 null
        //取出顺序固定
        for (int i = 0; i < 10; i++) {
            System.out.println("set=" + set);
        }
        set.remove(null);
        //遍历
        //方式1： 使用迭代器
        System.out.println("====使用迭代器====");
        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println("obj=" + obj);
        }

        //方式 2: 增强 for 本质就是迭代器
        System.out.println("=====增强 for====");
        for (Object o : set) {
            System.out.println("o=" + o);
        }
        //set接口对象，不能通过索引来获取
    }
}
```

## 十、Set接口实现类Hashset

### HashSet基本介绍

1. HashSet实现了Set接口

2. HashSet实际上是HashMap，源码

   ```java
   public Hashset() {
       map = new HashMap<>();
   }
   ```

3. 可以存放null值，但是只能有一个null

4. HashSet不保证元素是有序的，取决于hash后，再确定索引的结果。即不保证存放元素的顺序和取出顺序一致

5. 不能有重复元素/对象，即前面Set接口的使用

### 案例分析

```java
import java.util.HashSet;
@SuppressWarnings({"all"})
public class HashSet01 {
    public static void main(String[] args) {
        HashSet set = new HashSet()
            //说明
        //1. 在执行 add 方法后，会返回一个 boolean 值
        //2. 如果添加成功，返回 true, 否则返回 false
        //3. 可以通过 remove 指定删除哪个对象
        System.out.println(set.add("john"));//T
        System.out.println(set.add("lucy"));//T
        System.out.println(set.add("john"));//F
        System.out.println(set.add("jack"));//T
        System.out.println(set.add("Rose"));//T
        set.remove("john");
        System.out.println("set=" + set);//3 个
        //
        set = new HashSet();
        System.out.println("set=" + set);//0
        //4 Hashset 不能添加相同的元素/数据?
        set.add("lucy");//添加成功
        set.add("lucy");//加入不了
        set.add(new Dog("tom"));//OK
        set.add(new Dog("tom"));//Ok
        System.out.println("set=" + set);
        //在加深一下. 非常经典的面试题.
        //看源码，做分析， 先给小伙伴留一个坑，以后讲完源码，你就了然
        //去看他的源码，即 add 到底发生了什么?=> 底层机制. 
        set.add(new String("aaaa"));//ok
        set.add(new String("aaaa"));//加入不了. 
        System.out.println("set=" + set);
    }
}
class Dog { //定义了 Dog 类
    private String name;
    public Dog(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Dog{" +
            "name='" + name + '\'' +
            '}';
    }
}
```

### HashSet底层机制说明

HashSet底层是HashMap，HashMap的底层是 数组+链表+红黑树

**模拟简单的数组+链表结构**

```java
package collection;

public class HashSetStructure {
    public static void main(String[] args) {
        //模拟一个HashSet的底层（HashMap的底层结构）
        //1.创建一个数组，数组的类型是Node[]
        //2.可以直接将Node[] 数组称为表table
        Node[] table = new Node[16];
        //3.创建结点
        Node john = new Node("john", null);
        //4.添加进表中
        table[2] = john;
        Node jack = new Node("jack", null);
        //将jack结点挂载在john结点后
        john.next = jack;
        Node rose = new Node("Rose", null);
        //将rose结点挂载在jack结点后
        jack.next = rose;
        //新的元素add挂载在table还是node后面取决于元素哈希值的计算
        Node tom = new Node("Tome", null);
        table[3] = tom;
        System.out.println("table:" + table);

    }
}

class Node {//结点，存放数据并且可以指向下一个结点，从而形成链表
    Object item;//存放数据
    Node next;//指向下一个结点

    public Node(Object item, Node next) {
        this.item = item;
        this.next = next;
    }
}
```

**源码解读**

1. HashSe底层是HashMap,第一次添加时，table数组扩容到16，临界值（threshold）等于容量*加载因子（loadFactor  默认为0.75），即当table数组扩容为16时，临界值为16 * 0.75=12
2. 如果table数组使用到了临界值·12，就会扩容到16*2 = 32，新的临界值就是32 * 0.75 = 24，以此类推
3. 添加一个元素时，先得到hash值，会转化成 -> table的索引值: **h = key.hashCode() ^ (h >>> 16)   , tab[i = (n - 1) & hash]**
4. 找到存储数据表table，判断这个索引位置是否已经存放有元素
5. 如果没有，直接加入
6. 如果有，调用equals比较，一直比较到结尾，如果相同，就放弃添加，如果不相同，则添加到最后，添加成功后判断元素个数是否到达8，有则进入treeifyBin(tab, hash) 方法，判断**table数组长度(注意这里的长度是Node的数量)**是否大于64，大于则转化为红黑树，小于则扩容
7. 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化，将链表转化成红黑树

```java
import java.util.HashSet;
public class HashSetSource{
    public static void main(String[] args){
        HashSet hashSet = new HashSet();
        hashSet.add("java");//到此位置，第 1 次 add 分析完毕. 	
        hashSet.add("php");//到此位置，第 2 次 add 分析完毕
    	hashSet.add("java");
    	System.out.println("set=" + hashSet);
        /*

        1. 执行 HashSet()
        public HashSet() {
        	map = new HashMap<>();
        }
        2. 执行 add()
        public boolean add(E e) {//e = "java"
        	return map.put(e, PRESENT)==null;//(static) PRESENT = new Object(); 
        }
        3.执行 put() , 该方法会执行 hash(key) 得到 key 对应的hash值 
        算法：return(key == nll) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
        将hashCode的高16位与低16位进行异或运算减少hash冲突
        public V put(K key, V value) {//key = "java" value = PRESENT 共享 PRESENT没有意义，仅仅是占位
        	return putVal(hash(key), key, value, false, true);
        }
        4.执行 putVal
        
        final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
            Node<K,V>[] tab; Node<K,V> p; int n, i; //定义了辅助变量
            //table 就是 HashMap 的一个数组，类型是 Node[]
            //if 语句表示如果当前 table 是 null, 或者 大小=0
            //就进行第一次扩容，到默认的 16 个空间. 
            if ((tab = table) == null || (n = tab.length) == 0)
            	n = (tab = resize()).length;
            //(1)根据 key，得到 hash 去计算该 key 应该存放到 table 表的哪个索引位置 算法：(n - 1) & hash
            //并把这个位置的对象，赋给 p
            //(2)判断 p 是否为 null
            //(2.1) 如果 p 为 null, 表示还没有存放元素, 就创建一个 Node (key="java",value=PRESENT)
            //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)
            if ((p = tab[i = (n - 1) & hash]) == null)
                tab[i] = newNode(hash, key, value, null);
        	else {
        		//一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建
       			Node<K,V> e; K k; 
        		
        		//如果当前索引位置对应的链表的第一个元素和准备添加的 key 的 hash 值一样
        		//并且满足 下面两个条件之一:
                //(1) 准备加入的 key 和 p 指向的 Node 结点的 key 是同一个对象
                //(2) p 指向的 Node 结点的 key 的 equals() 和准备加入的 key 比较后相同
                //就不能加入
        		if (p.hash == hash &&
        			((k = p.key) == key || (key != null && key.equals(k))))
        			e = p;
                //再判断 p 是不是一颗红黑树, //如果是一颗红黑树，就调用 putTreeVal , 来进行添加
                else if (p instanceof TreeNode)
                	e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                else {//如果 table 对应索引位置，已经是一个链表, 就使用 for 循环比较
                    //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后，然后break
                    // 注意在把元素添加到链表后，立即判断 该链表是否已经达到 8 个结点
                    // , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)
                    // 注意，在转成红黑树时，要进行判断, 判断条件
                    // if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY(64))
                    	// resize();
                    // 如果上面条件成立，先 table 扩容. // 只有上面条件不成立时，才进行转成红黑树
                    //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接 break
                    for (int binCount = 0; ; ++binCount) {
                    	if ((e = p.next) == null) {
                    		p.next = new Node(hash, key, value, null);
                            if (binCount >= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st
                                treeifyBin(tab, hash);
                            break;
                		}
                        if (e.hash == hash
                            ((k = e.key) == key || (key != null && key.equals(k))))
                            break;
                        p = e;
                	}
                }
                if (e != null) { // existing mapping for key
                	V oldValue = e.value;
                	if (!onlyIfAbsent || oldValue == null)
                		e.value = value;
               		afterNodeAccess(e);
                	return oldValue;
                }
        }
        ++modCount;
        //size 就是我们每加入一个结点 Node(k,v,h,next), size++
        if (++size > threshold)
        	resize();//扩容
        afterNodeInsertion(evict);//这个方法是为了给HashMap子类实现的
        return null;
        }
        */
        }
    }
}
```

**扩容源码解读**

```java
package collection;

import java.util.HashSet;

public class HashSetIncrement {
    public static void main(String[] args) {
        /*
        HashSet 底层是 HashMap, 第一次添加时，table 数组扩容到 16，
        临界值(threshold)是 16*加载因子(loadFactor)是 0.75 = 12
        如果 table 数组使用到了临界值 12,就会扩容到 16 * 2 = 32
        新的临界值就是 32*0.75 = 24, 依次类推
        */
        HashSet hashSet = new HashSet();
        // for(int i = 1; i <= 100; i++) {
        // hashSet.add(i);//1,2,3,4,5...100
        // }
        /*
        在 Java8 中, 如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是 8 )，
        并且 table 的大小 >= MIN_TREEIFY_CAPACITY(默认 64),就会进行树化(红黑树), 否则仍然采用数组扩容机制
        */
        // for(int i = 1; i <= 12; i++) {
        // hashSet.add(new A(i));//
        // }
        /*
        当我们向 hashset 增加一个元素，-> Node -> 加入 table , 就算是增加了一个 size++
        */
        for (int i = 1; i <= 7; i++) {//在 table 的某一条链表上添加了 7 个 A 对象
            hashSet.add(new A(i));//
        }
        for (int i = 1; i <= 7; i++) {//在 table 的另外一条链表上添加了 7 个 B 对象
            hashSet.add(new B(i));//
        }
    }
}

class B {
    private int n;

    public B(int n) {
        this.n = n;
    }

    @Override
    public int hashCode() {
        return 200;
    }
}

class A {
    private int n;

    public A(int n) {
        this.n = n;
    }

    @Override
    public int hashCode() {
        return 100;
    }
}
```

案例分析

```java
package collection;

import java.util.HashSet;
import java.util.Objects;

public class HashSetExercise {
    public static void main(String[] args){
        /**
         定义一个 Employee 类，该类包含：private 成员属性 name,age 要求:
         创建 3 个 Employee 对象放入 HashSet 中
         当 name 和 age 的值相同时，认为是相同员工, 不能添加到 HashSet 集合中
         */
        HashSet hashSet = new HashSet();
        hashSet.add(new Employee("milan", 18));//ok
        hashSet.add(new Employee("smith", 28));//ok
        hashSet.add(new Employee("milan", 18));//加入不成功. //回答,加入了几个?不重写hashCode和equals的话 加入3个
        System.out.println("hashSet=" + hashSet);
    }
}
class Employee{
    private String name;
    private int age;

    public Employee(String name ,int age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    @Override
    public boolean equals(Object o) {
        if(this == o) return true;
        if(o == null || getClass()!= o.getClass()) return false;
        Employee employee = (Employee) o;
        return age == employee.age && Objects.equals(name, employee.name);
    }
    //如果name和age相同，则返回相同的hash值
    @Override
    public int hashCode(){
        return Objects.hash(name,age);
    }
}
```

## 十一、Set接口实现类LinkedHashSet

### LinkedHashSet基本介绍

1. LinkedHashSet 是 HashSet的子类

2. LinkedHashSet 底层是一个 LinkedHashMap ，LinkedHashMap是HashMap的子类，底层维护了一个数组+双向链表（LinkedHashSet 有 head 和tail）

3. 存放的结点类型是LinkedHashMap$Entry，数组是hashMap$Node[] ,存放的元素/数据是LinkedHashMap$Entry,(静态内部类)

4. 每一个Entry节点有before和after属性，这样可以形成双向链表

5. LinkedHashSet 根据元素的 hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的，在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加 原则和hashset一样）

   ```java
   tail.next = new Element; //示例代码
   newElement.pre = tail;
   tail = newElement;
   //这样的话，我们遍历LinkedHashSet 也能确保插入的顺序和遍历顺序
   ```

   

6. LinkedHashSet 不允许添加重复元素

## 十二、Set接口实现类TreeSet

```java
package collection;

import java.util.Comparator;
import java.util.TreeSet;

public class TreeSet_ {
    public static void main(String[] args) {
        //1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的
        //2. 如果希望添加的元素，按照字符串大小来排序
        //3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)，并指定排序规则
        //4. 简单看看源码
    /*
    1. 构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator
        public TreeMap(Comparator<? super K> comparator) {
            this.comparator = comparator;
        }
    2. 在 调用 treeSet.add("tom"), 在底层会执行到
        if (cpr != null) {//cpr 就是我们的匿名内部类(对象)
            do {
                parent = t;
                //动态绑定到我们的匿名内部类(对象)compare方法
                cmp = cpr.compare(key, t.key);
            if (cmp < 0)
            	t = t.left;
            else if (cmp > 0)
            	t = t.right;
            else //如果相等，即返回 0,这个 Key 就没有加入，注意setValue修改的是value,Set中value都是相同的 PRESENR
            	return t.setValue(value);
            } while (t != null);
        }
    */
        // TreeSet treeSet = new TreeSet();
        TreeSet treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //下面 调用 String 的 compareTo 方法进行字符串大小比较
                //如果要求加入的元素，按照长度大小排序
                //return ((String) o2).compareTo((String) o1);
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        //添加数据. treeSet.add("jack")
        treeSet.add("tom");//3
        treeSet.add("sp");
        treeSet.add("a");
        treeSet.add("abc");//3
        System.out.println("treeSet=" + treeSet);
    }
}
```



## 十三、Map接口和常用方法

### Map接口实现类的特点

注意：这里是JDK8的Map接口特点

1. Map与Collection并列存在。用于保存具有映射关系的数据：key-value
2. Map中的 key 和 value 可以是任意引用类型的数据，会封装到HashMap$Node对象中
3. Map中的key不允许重复，原因和HashSet一样
4. Map中的value可以重复
5. Map的 key 可以为 null ，value 也可以为 null ，注意 key 为 null ，只能有一个，value 为 null ，可以有多个
6. 常用String类作为Map 的 key
7. key 和 value 之间存在单向一对一关系，即通过指定的 key总能找到对应的 value
8. Map存放数据的key-value，一对k-v是放在一个HashMap$Node中的，又因为Node实现了Entry接口，有些地方也说 一对k-v就是一个Entry

```java
package collection;

import java.util.HashMap;
import java.util.Map;

public class Map_ {
    public static void main(String[] args) {
        //Map 接口实现类的特点, 使用实现类 HashMap
        //1. Map 与 Collection 并列存在。用于保存具有映射关系的数据:Key-Value(双列元素)
        //2. Map 中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中
        //3. Map 中的 key 不允许重复，原因和 HashSet 一样，前面分析过源码. //4. Map 中的 value 可以重复
        //5. Map 的 key 可以为 null, value 也可以为 null ，注意 key
        // 只能有一个，value 为 null ,可以多个
        //6. 常用 String 类作为 Map 的 key
        //7. key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value
        Map map = new HashMap();
        map.put("no1", "韩顺平");//k-v
        map.put("no2", "张无忌");//k-v
        map.put("no1", "张三丰");//当有相同的 k , 就等价于替换. map.put("no3", "张三丰");//k-v
        map.put(null, null); //k-v
        map.put(null, "abc"); //等价替换
        map.put("no4", null); //k-v
        map.put("no5", null); //k-v
        map.put(1, "赵敏");//k-v
        map.put(new Object(), "金毛狮王");//k-v
        // 通过 get 方法，传入 key ,会返回对应的 value
        System.out.println(map.get("no2"));//张无忌
        System.out.println("map=" + map);
    }
}
```



```java
package collection;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class Map_2 {
    public static void main(String[] args) {
        Map map = new HashMap();

        map.put("NO1", "张三");
        map.put("NO2", "李四");
        //1. k-v 最后是HashMap$Node node = newNode(hash, key, value, null)
        //2. k-v 为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素类型Entry，
        //而一个Entry对象就有k,v EntrySet<Entry<k,v>> ,即 transient Set<Map.Entry<K,V>> entrySet;
        //3. entrySet中，定义的类型是Map.Entry ，但实际上存放的还是 HashMap$Node entrySet中存放的是Node的引用
        //这是因为HashMap$Node implements Map.Entry
        //4. 当把 HashMap$Node 对象存放到 entrySet 就方便我们的遍历，因为 Map.Entry提供了两个重要方法
        // K getKey();  V getValue(); Set KeySet(); Collection Values();
        Set set = map.entrySet();
        System.out.println(set.getClass());
        for (Object obj : set) {
            System.out.println(obj.getClass());
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + "-" + entry.getValue());
        }
    }
}
```

### Map接口的常用方法

1. put：添加
2. remove: 根据键删除映射关系
3. get: 根据键获取值
4. size：获取元素个数
5. isEmpty：判断个数是否为0
6. clear: 清楚
7. containsKey：查找键是否存在

### Map接口遍历方法

1. containsKey 查找键是否存在
2. keySet 获取所有的键
3. entrySet 获取所有关系k-v
4. values 获取所有的值

```java
package collection;

import java.util.*;

public class MapFor {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");

        //第一组: 先取出 所有的 Key , 通过 Key 取出对应的 Value
        //(1) 增强 for
        System.out.println("-----第一种方式-------");
        Set keyset = map.keySet();
        for(Object key : keyset) {
            System.out.println(key + "-" + map.get(key));
        }
        //(2) 迭代器
        System.out.println("-----第二种方式-------");
        Iterator iterator = keyset.iterator();
        while( iterator.hasNext()) {
            Object key = iterator.next();
            System.out.println(key + "-" + map.get(key));
        }

        //第二组: 把所有的 values 取出
        Collection values = map.values();
        //这里可以使用所有的 Collections 使用的遍历方法
        //(1) 增强 for
        System.out.println("---取出所有的 value 增强 for----");
        for (Object value : values) {
            System.out.println(value);
        }
        //(2) 迭代器
        System.out.println("---取出所有的 value 迭代器----");
        Iterator iterator2 = values.iterator();
        while (iterator2.hasNext()) {
            Object value = iterator2.next();
            System.out.println(value);
        }
        //第三组: 通过 EntrySet 来获取 k-v
        Set entrySet = map.entrySet();// EntrySet<Map.Entry<K,V>>
        //(1) 增强 for
        System.out.println("----使用 EntrySet 的 for 增强(第 3 种)----");
        for (Object entry : entrySet) {
            //将 entry 转成 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + "-" + m.getValue());
        }
        //(2) 迭代器
        System.out.println("----使用 EntrySet 的 迭代器(第 4 种)----");
        Iterator iterator3 = entrySet.iterator();
        while (iterator3.hasNext()) {
            Object entry = iterator3.next();
            //System.out.println(next.getClass());//HashMap$Node -实现-> Map.Entry (getKey,getValue)
            //向下转型 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + "-" + m.getValue());
        }
    }
}
```

## 十四、Map接口实现类HashMap

### HashMap基本介绍

1. Map接口的常用实现类：HashMap，HashTable 和 Properties
2. HashMap 是Map接口使用频率最高的实现类
3. HashMap是以Key-val 对的方式来存储数据的 HashMap$Node
4. key 不能重复，如果重复的话会覆盖掉原来key-val，等同于修改val，val可以重复，允许使用null作为key和value
5. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的 HashMap底层 数组+链表+红黑树
6. HashMap没有实现同步，因此是线程不安全的，方法没有做到同步互斥操作，没有synchronized

### HashMap底层机制及源码剖析

1. HashMap底层维护了Node类型数组table， 默认为null
2. 当创建元素时，将加载因子（loadfactor)初始化为 0.75
3. 当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素则直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。
4. 第一次添加键值对时，需要扩容table容量为16，临界值 threshold 为12 （16*0.75）
5. 后面再次扩容时，需要扩容table容量为原来的2倍，临界值为原来的两倍，以此类推
6. 在Java8中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认为8），并且table的大小 >= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化转化成红黑树

```java
package collection;

import java.util.HashMap;

public class HashMapSource1 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("java", 10);//true
        map.put("php", 10);//true
        map.put("java", 20);//替换value
        /*
        1、执行构造器 new HashMap()
        	初始化加载因子 this.loadFactor = DEFAULT_LOAD_FACTOR 0.75
        	HashMap$Node[] table = null
        2、 执行put 调用 hash方法，计算key的hash值 (h = key.hashCode())^(h>>>16)
        	public V put(K key, V value) {//K = "java" value = 10
            	return putVal(hash(key), key, value, false, true);
            }
        3、执行putVal
        final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
            Node<K,V>[] tab; Node<K,V> p; int n, i;//辅助变量
            //如果底层的 table 数组为 null, 或者 length =0 , 就扩容到 16
            if ((tab = table) == null || (n = tab.length) == 0)
            	n = (tab = resize()).length;
            //取出 hash 值对应的 table 的索引位置的 Node, 如果为 null, 就直接把加入的 k-v
            //, 创建成一个 Node ,加入该位置即可
            if ((p = tab[i = (n - 1) & hash]) == null)
            	tab[i] = newNode(hash, key, value, null);
            else {
                Node<K,V> e; K k;//辅助变量
                // 如果 table 的索引位置的 key 的 hash 相同和新的 key 的 hash 值相同，
                // 并 满足(table 现有的结点的 key 和准备添加的 key 是同一个对象 || equals 返回真)
                // 就认为不能加入新的 k-v
                if (p.hash == hash &&
                	((k = p.key) == key || (key != null && key.equals(k))))
                	e = p;
            	else if (p instanceof TreeNode)//如果当前的 table 的已有的 Node 是红黑树，就按照红黑树的方式处
            理
            		e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                else {
                	//如果找到的结点，后面是链表，就循环比较
                	for (int binCount = 0; ; ++binCount) {//死循环
                		if ((e = p.next) == null) {//如果整个链表，没有和他相同,就加到该链表的最后
                			p.next = newNode(hash, key, value, null);
                            //加入后，判断当前链表的个数，是否已经到 8 个，到 8 个，后
                            //就调用 treeifyBin 方法进行红黑树的转换
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        	treeifyBin(tab, hash);//里面还需要判断是否size到达64，见第5点
                        break;
                		}
                        if (e.hash == hash && //如果在循环比较过程中，发现有相同,就 break,就只是替换 value
                        	((k = e.key) == key || (key != null && key.equals(k))))
            				break;
            			p = e;
            		}
            	}
            	if (e != null) { // existing mapping for key
            		V oldValue = e.value;
                    if (!onlyIfAbsent || oldValue == null)
                        e.value = value; //替换，key 对应 value
                    afterNodeAccess(e);
                    return oldValue;
            	}
            }
            ++modCount;//每增加一个 Node ,就 size++
            if (++size > threshold[12-24-48])//如 size > 临界值，就扩容
            	resize();
            afterNodeInsertion(evict);
            return null;
            }
            5. 关于树化(转成红黑树)
            //如果 table 为 null ,或者大小还没有到 64，暂时不树化，而是进行扩容. //否则才会真正的树化 -> 剪枝
            final void treeifyBin(Node<K,V>[] tab, int hash) {
                int n, index; Node<K,V> e
            	if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
            		resize();
            }
        */
    }
}
```

## 十五、Map接口实现类HashTable

### HashTable基本介绍

1. 存放的元素是键值对：key-val
2. HashTable的键和值都不能为null，否则会抛出NullPointerException
3. HashTable使用方法基本上和HashMap相同
4. HashTable是线程安全的（synchronized），HashMap是线程不安全的
5. 底层数组为 HashTable$Entry[] 初始大小为11

### HashTable和HashMap对比

|           | 版本 | 线程安全（同步） | 效率 | 允许null键null值 |
| --------- | ---- | ---------------- | ---- | ---------------- |
| HashMap   | 1.2  | 不安全           | 高   | 允许             |
| HashTable | 1.0  | 安全             | 较低 | 不允许           |

## 十六、Map接口实现类-Properties

### Properties基本介绍

1. Properties类继承自HashTable类并实现了Map接口，存储数据的形式也是键值对
2. 使用特点和HashTable类似
3. Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改， xxx.properties 文件通常作为配置文件

### Properties基本使用

```java
package collection;

import java.util.Properties;

public class Properties_ {
    public static void main(String[] args) {

        //1. Properties 继承 Hashtable
        //2. 可以通过 k-v 存放数据，当然 key 和 value 不能为 null
        //增加
        Properties properties = new Properties();
        //properties.put(null, "abc");//抛出 空指针异常
        //properties.put("abc", null); //抛出 空指针异常
        properties.put("john", 100);//k-v
        properties.put("lucy", 100);
        properties.put("lic", 100);
        properties.put("lic", 88);//如果有相同的 key ， value 被替换
        System.out.println("properties=" + properties);
        //通过 k 获取对应值
        System.out.println(properties.get("lic"));//88
        //删除
        properties.remove("lic");
        System.out.println("properties=" + properties);
        //修改
        properties.put("john", "约翰");
        System.out.println("properties=" + properties);
    }
}
```

## 十七、Map接口实现类TreeMap

```java
package collection;

import java.util.Comparator;
import java.util.TreeMap;

public class TreeMap_ {
    public static void main(String[] args) {
        //使用默认的构造器，创建 TreeMap, 是无序的(也没有排序)
        /*
        要求：按照传入的 k(String) 的大小进行排序
        */
        // TreeMap treeMap = new TreeMap();
        TreeMap treeMap = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //按照传入的 k(String) 的大小进行排序
                //按照 K(String) 的长度大小排序
                //return ((String) o2).compareTo((String) o1);
                return ((String) o2).length() - ((String) o1).length();
            }
        });
        treeMap.put("jack", "杰克");
        treeMap.put("tom", "汤姆");
        treeMap.put("kristina", "克瑞斯提诺");
        treeMap.put("smith", "斯密斯");
        treeMap.put("hsp", "韩顺平");//加入不了
        System.out.println("treemap=" + treeMap);
        /*
        解读源码：
        1. 构造器. 把传入的实现了 Comparator 接口的匿名内部类(对象)，传给给 TreeMap 的 comparator
            public TreeMap(Comparator<? super K> comparator) {
            	this.comparator = comparator;
            }
        2. 调用 put 方法
        2.1 第一次添加, 把 k-v 封装到 Entry 对象，放入 root
            Entry<K,V> t = root;
            if (t == null) {
                compare(key, key); // type (and possibly null) check
                root = new Entry<>(key, value, null);
                size = 1;
                modCount++;
                return null;
            }
        2.2 以后添加
            Comparator<? super K> cpr = comparator;
            if (cpr != null) {
                do { //遍历所有的 key , 给当前 key 找到适当位置
                    parent = t;
                    cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的 compare
                    if (cmp < 0)
                    	t = t.left;
                    else if (cmp > 0)
                    	t = t.right;
                    else //如果遍历过程中，发现准备添加 Key 和当前已有的 Key比较返回0 ，则不添加key，替换旧的value
                    	return t.setValue(value);
                } while (t != null);
            }
        */
    }
}
```



## 十八、开发中如何选择集合实现类

在开发中，选择说明集合实现类，主要取决于**业务操作特点**，然后根据集合实现类特性进行选择，分析如下：

1. 先判断存储的类型（一组对象[单列] 或 一组键值对[双列] )

2. 一组对象[单列]: Collection接口

   1. 允许重复： List
      1. 增删多：LinkedList（底层维护了一个双向链表）
      2. 改查多： ArrayList（底层维护 Object类型的可变数组）

   1. 不允许重复： Set
      1. 无序：HashSet（底层是HashMap，维护了一个哈希表 即数组+链表+红黑树）
      2. 排序：**TreeSet**
      3. 插入和取出循序一致：LinkedHashSet（底层维护哈希表+双向链表）

3. 一组键值对[双列]：Map接口

   1. 键无序：HashMap（底层哈希表）
   2. 键排序：**TreeMap**
   3. 键插入和取出顺序一直：LinkedHashMap
   4. 读取文件：Properties

## 十九、Collections工具类

### Collections工具类介绍

1. Collections 是一个操作Set，List和Map等集合的工具类
2. Collections 中提供了一系列的静态的方法对集合元素进行排序、查询和修改等操作

### 排序、查找、替换操作

1. reverse(List) 反转
2. shuffle(List) 对List集合元素进行随机排序
3. sort(List) 根据元素的自然顺序对指定List集合元素按升序排序
4. sort(List, Comparator)
5. swap(List, int, int)
6. Object max(Collection)
7. Object max(Collection, Comparator)
8. Object min(Collection)
9. Object min(Collection, Compatator)
10. int frequency(Collection, Object)
11. void copy(List dest, List src) 将src中的内容复制到dest中，注意对长度有限制
12. boolean replaceAll(List list, Object oldVal, Object newVal)

```java
package collection;

import java.util.*;

public class CollectionsMethod {
    public static void main(String[] args) {
        //创建 ArrayList 集合，用于测试.
        List list = new ArrayList();
        list.add("tom");
        list.add("smith");
        list.add("king");
        list.add("milan");
        list.add("tom");
        // reverse(List)：反转 List 中元素的顺序
        Collections.reverse(list);
        System.out.println("list=" + list);
        // shuffle(List)：对 List 集合元素进行随机排序
        // for (int i = 0; i < 5; i++) {
        // 		Collections.shuffle(list);
        // 		System.out.println("list=" + list);
        // }
        // sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
        Collections.sort(list);
        System.out.println("自然排序后：");
        System.out.println("list=" + list);
        // sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
        Collections.sort(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //可以校验是否为String
                if (!(o1 instanceof String && o2 instanceof String)) {
                    return 0;
                }
                return ((String) o2).length() - ((String) o2).length();
            }
        });
        // swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
        Collections.swap(list, 0, 1);
        System.out.println("交换后的情况");
        System.out.println("list=" + list);
        //Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
        System.out.println("自然顺序最大元素=" + Collections.max(list));
        //Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
        //比如，我们要返回长度最大的元素
        Object maxObject = Collections.max(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        System.out.println("长度最大的元素=" + maxObject);
        //Object min(Collection)
        //Object min(Collection，Comparator)
        //上面的两个方法，参考 max 即
        //int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
        System.out.println("tom 出现的次数=" + Collections.frequency(list, "tom"));

        //void copy(List dest,List src)：将 src 中的内容复制到 dest
        ArrayList dest = new ArrayList();
        //为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size()一样
        for (int i = 0; i < list.size(); i++) {
            dest.add("");
        }
        //拷贝
        Collections.copy(dest, list);
        System.out.println("dest=" + dest);

        //boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值
        //如果 list 中，有 tom 就替换成 汤姆
        Collections.replaceAll(list, "tom", "汤姆");
        System.out.println("list 替换后=" + list);
    }
}
```



**练习题**

```java
package collection;

import java.util.HashSet;
import java.util.Objects;

/**
 * @program: study
 * @description:
 * @author: xiongfeng
 * @create: 2022-03-02 00:39
 **/
public class HomeWork06 {
    public static void main(String[] args) {
        //判断输出为什么
        HashSet<Object> set = new HashSet<>();
        Person person1 = new Person(1001,"AA");
        Person person2 = new Person(1002,"BB");
        set.add(person1);
        set.add(person2);
        person1.name = "CC";
        set.remove(person1);
        System.out.println(set);
        set.add(new Person(1001,"CC"));
        System.out.println(set);
        set.add(new Person(1001,"AA"));
        System.out.println(set);
    }
}

class Person {
    public String name;
    public int id;

    public Person(int id, String name) {
        this.name = name;
        this.id = id;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return id == person.id && Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, id);
    }

    @Override
    public String toString() {
        return "person{" +
                "name='" + name + '\'' +
                ", id=" + id +
                '}';
    }
}
```











