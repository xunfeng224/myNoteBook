**面向对象复习**

# 类与对象

类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型. 
对象是具体的，实际的，代表一个具体事物, 即 是实例. 
类是对象的模板，对象是类的一个个体，对应一个实例 

# 类和对象的内存分配机制

**Java 内存的结构分析** 

1) 栈： 一般存放基本数据类型(局部变量) 
2) 堆： 存放对象(Cat cat , 数组等) 
3) 方法区：常量池(常量，比如字符串)， 类加载信息

```java
Person p = new Person();
p.name = “jack”;
p.age = 1
```

1. 先加载 Person 类信息(属性和方法信息, 只会加载一次) 
2. 在堆中分配空间, 进行默认初始化(看规则) 
3. 把地址赋给 p , p就指向对象
4. 进行指定初始化， 比如 p.name =”jack”

**对象在内存中存在形式**

![HO8jim1GCX7qvSW](https://xunfeng-images.oss-cn-shenzhen.aliyuncs.com/xfTyporaImages/HO8jim1GCX7qvSW-16634126487041.png)

cat称为对象的引用，真正的对象在堆中

new的时候类的信息会加载到方法区

# 成员变量和成员方法

成员变量（属性）: 访问修饰符 属性类型 属性名

**成员方法**（方法）：访问修饰符 返回值 方法名 ()形参列表 {}方法体

访问修饰符 返回数据类型 方法名（形参列表..） {//方法体 语句； return 返回值; } 

1) 形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num
2) 返回数据类型：表示成员方法输出, void 表示没有返回值 
3)  方法主体：表示为了实现某一功能代码块 
4)  return 语句不是必须的

## 方法的调用机制原理

![nfi7GT26dVQu3rt](https://xunfeng-images.oss-cn-shenzhen.aliyuncs.com/xfTyporaImages/nfi7GT26dVQu3rt.png)

## **访问修饰符** 

(作用是控制 方法使用的范围) 如果不写默认访问，[有四种: public, protected, 默认default, private]

## **返回数据类型** 

1.  一个方法最多有一个返回值 [思考，如何返回多个结果 返回数组 ]
2.  返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 
3. 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容 
4.  如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return 

## **形参列表**

1. 一个方法可以有0个参数也可以有多个参数，中间用逗号隔开
2. 参数类型可以为任意类型，包含基本类型或引用类型
3. 调用带参数的方法时，一定对应着参数列表传入相同类型或者兼容类型的参数
4. 方法定义时的参数称为形式参数，简称形参，方法调用时传入的参数称为实际参数，简称实参，实参和形参的类型要一致或者兼容、个数、顺序必须一致

## **方法体**

里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即方法不能嵌套定义

## **方法调用细节**

1. 同一个类中的方法调用：直接调用即可，
2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如 对象名.方法名(参数);
3. 跨类的方法调用和方法的访问修饰符相关

## 传参机制

基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参





# 方法递归调用

1.**递归介绍**

递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变 得简洁

2.**递归解决的问题**

1.各种数学问题：8皇后问题，汉诺塔，阶乘问题，迷宫问题，求和篮子的问题
2.各种算法中：快排，归并排序，二分查找，分治算法
3.将用栈解决的问题-->使用递归代码比较简洁

3.**实例**

![cuvE3jI5OM9rq2K](https://xunfeng-images.oss-cn-shenzhen.aliyuncs.com/xfTyporaImages/cuvE3jI5OM9rq2K.png)



4.**递归规则**

执行一个方法时，就创建一个新的受保护的独立空间（栈空间）

方法的局部变量是独立的，不会相互影响

如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据

递归必须向退出递归的条件逼近，否则就是无限递归，出现Stack Overflow

当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕



5.**递归调用实例练习**

求斐波那锲数列第n项

```java
/**
 * @program: study
 * @description: 求斐波那锲数列第n项
 * @author: xiongfeng
 * @create: 2022-01-15 11:14
 **/
public class Fibonacci {
    public static void main(String[] args) {
        Fibonacci fibonacci = new Fibonacci();
        long n = fibonacci.Fibonacci(48);
        System.out.println(n);
    }

    private long Fibonacci(int n) {
        if (n < 1) {
            return -1;
        }
        if (n == 1 || n == 2) {
            return 1;
        } else {
            return Fibonacci(n - 1) + Fibonacci(n - 2);
        }
    }
}
```

 猴子吃桃问题

```java
/**
 * @program: study
 * @description: 猴子吃桃问题
 * @author: xiongfeng
 * @create: 2022-01-15 11:29
 **/
public class MonkeyEatingPeach {
    //猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！
    //以后每天猴子都吃其中的一半，然后再多吃一个。当到第 10 天时，
    //想再吃时（即还没吃），发现只有 1 个桃子了。问题：最初共多少个桃子
    public static void main(String[] args) {
        MonkeyEatingPeach monkeyEatingPeach = new MonkeyEatingPeach();
        //day表示第十天，sum表示桃子总数
        int day = 10, sum = 1;
        int finalsum = monkeyEatingPeach.eat(day, sum);
        System.out.println(finalsum);
    }

    private int eat(int day,int sum) {
        if (day == 1) {
            return sum;
        }else {
            return eat(day-1,(sum+1)*2);
        }
    }
}
```

老鼠走迷宫问题



```java
/**
 * @program: study
 * @description: 老鼠走迷宫
 * @author: xiongfeng
 * @create: 2022-01-15 11:43
 **/
public class EasyMaze {
    //二维数组迷宫中1表示障碍物，0表示可以走的路，因为有一层围墙，所以起点为[1][1]，终点为[row-2][colunm-2]，要求找出一条从[1][1]到[row-2][colunm-2]的路径
    
    public static void main(String[] args) {
        //迷宫
        int row = 8, column = 7;
        int[][] maze = new int[8][7];
        //给迷宫加上围墙
        for (int i = 0; i < maze.length; i++) {
            maze[i][0] = 1;
            maze[i][maze[0].length - 1] = 1;
        }
        for (int i = 0; i < maze[0].length; i++) {
            maze[0][i] = 1;
            maze[maze.length - 1][i] = 1;
        }
        //给迷宫加上障碍物
        maze[3][1]=1;
        maze[3][2]=1;
        maze[4][3]=1;
        printMaze(maze);
        //找出路径
        EasyMaze easyMaze = new EasyMaze();
        easyMaze.findWay(maze,1,1);
        printMaze(maze);
    }

    //绘制当前迷宫
    private static void printMaze(int[][] maze) {
        System.out.println("-----当前迷宫----");
        for (int i = 0; i < maze.length; i++) {
            for (int j = 0; j < maze[i].length; j++) {
                System.out.print(maze[i][j] + " ");
            }
            System.out.println();
        }
    }

    //findWay用来专门找出迷宫的路径
    //maze 为迷宫，包括路径，row,cloumn为当前位置
    //maze中0代表可以走的位置，1代表障碍物不能走，2表示可以走，3表示走过，但是走不通为死路
    //终点为迷宫右下角 例如：maze：int[8][7],则终点为int[6][5]
    //则如果终点int[6][5]的值为2，表明找到通路，可以结束，否则继续找
    //找路策略，优先往  下->右->上->下

    private boolean findWay(int[][] maze, int row, int column) {
        //说明已经找到路了
        if (maze[6][5] == 2) {
            return true;
        } else {
            //当前这个位置为0表示可以走
            if (maze[row][column] == 0) {
                //我们假定可以走通
                maze[row][column] = 2;
                //使用找路策略，来确定该位置是否真的可以走通
                //下->右->上->左
                if (findWay(maze, row + 1, column)) {
                    return true;
                } else if (findWay(maze, row, column + 1)) {
                    return true;
                } else if (findWay(maze, row - 1, column)) {
                    return true;
                } else if (findWay(maze, row, column - 1)) {
                    return true;
                } else {
                    maze[row][column] = 3;
                    return false;
                }


            } else {
                //map[row][colunm] =1,2,3
                return false;
            }
        }
    }
}
```

汉诺塔问题

```java
/**
 * @program: study
 * @description: 汉诺塔
 * @author: xiongfeng
 * @create: 2022-01-15 15:27
 **/
public class HanoiTower {
    public static void main(String[] args) {
        Tower tower = new Tower();
        tower.move(5,'A','B','C');
    }
}

class Tower {
    //num表示要移动的个数,a，b，c分别表示A塔，B塔，C塔
    public void move(int num, char a, char b, char c) {
        //如果只有一个盘
        if (num == 1) {
            System.out.println(a + "->" + c);
        }else{
            //如果有很多盘，可以看成两个，最下面的盘和上面的所有盘
            //(1)先移动上面所有的盘到b ，借助c
            move(num -1,a,c,b);
            //(2)把下面的这个盘移动到c
            System.out.println(a+"->"+c);
            //(3)再把b塔的所有盘，移动到c，借助a
            move(num -1,b,a,c);
        }
    }
}
```

八皇后问题

```java
```



# 方法重载(OverLoad)

概念：java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致

**重载的好处**

重载的最直接作用是方便了程序员可以根据不同的参数个数，顺序，类型，自动匹配方法，减少写过个函数名或方法名的重复步骤。并且减轻了记函数名的麻烦。

**注意事项**

1. 方法名必须相同
2. **形参列表必须不同**（形参类型、个数、顺序，至少有一样不同，参数名无要求)
3. 返回值无要求

# 可变参数

概念：java允许将一个类中多个同名且同功能但参数个数不同的方法，封装成一个方法

```java
public class VarParameter01 {
    //编写一个 main 方法
    public static void main(String[] args) {
        HspMethod m = new HspMethod();
        System.out.println(m.sum(1, 5, 100)); //106
        System.out.println(m.sum(1, 19)); //20
    }
}

class countMethod {
    //可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。
//可以使用方法重载
//    public int sum(int n1, int n2) {//2 个数的和
//        return n1 + n2;
//    }
//
//    public int sum(int n1, int n2, int n3) {//3 个数的和
//        return n1 + n2 + n3;
//    }
//
//    public int sum(int n1, int n2, int n3, int n4) {//4 个数的和
//        return n1 + n2 + n3 + n4;
//    }
//..... //上面的三个方法名称相同，功能相同, 参数个数不同-> 使用可变参数优化
    //1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)
//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组
//3. 遍历 nums 求和即可
    public int sum(int... nums) {
//System.out.println("接收的参数个数=" + nums.length);
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            res += nums[i];
        }
        return res;
    }
}
```

**注意事项**

1. 可变参数的实参可以为0个或者多个
2. 可变参数的实参可以为数组
3. 可变参数的本质为数组
4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
5. 一个形参列表中只能出现一个可变参数

# 作用域(Scope)

1. 在java编程中，主要的变量就是属性（成员变量）和局部变量（还有静态变量）

2. 我们说的局部变量一般是指在成员方法中定义的变量（还有代码块中的变量）

3. java中作用域的分类

   a.全局变量：也就是属性，作用域为整个类体

   b.局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中

4. 全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值

5. 成员变量可以被访问修饰符修饰，改变作用域

**注意**

1. 属性和局部变量可以重名，访问时遵循最近原则
2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名
3. 属性生命周期比较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁，局部变量生命周期短，伴随着它的代码块执行而创建，伴随着代码块的结束而销毁，即在一次方法调用过程中
4. 作用域不同
   全局变量/属性：可以被本类使用，或者其他类使用（通过对象调用）
   局部变量：只能在本类中对应的方法中使用
5. 修饰符不用
   全局变量可以加修饰符
   局部变量不可以加修饰符

# 构造器(constructor)

概念：构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。

**基本语法**

[修饰符] 方法名(形参列表){ 

方法体; 

}

**基本规则**

1. 
2.  
3.  
4. 

**注意事项**

1. 一个类可以定义多个不同的构造器，即构造器重载
2. 方法名和类名字必须一样 。构造器的修饰符可以默认，也可以是 public protected private 
3. 参数列表 和 成员方法一样的规则 
4. 构造器没有返回值
5. 构造器是完成对象的初始化，并不是创建对象
6. 构造器的调用, 由系统完成，在创建对象时，系统会自动的调用该类的构造器完成对象的初始化
7. 如果没有定义构造器，系统会自动给类生成一个默认无参构造器（默认构造器）
8. 如果定义了自己的构造器，默认的构造器就被覆盖了，就不能使用默认的无参构造器，除非显式的定义一下

# 对象创建流程

```java
class Person{
    int age = 90;
    String name;
    Person(String n, int a){
        name=n;
        age=a;
    }
}
Person p = new Person("xiaoming",20);
```

1. 先在方法区加载Person类信息（Person.class),只会加载一次
2. 在堆中分配空间（地址）
3. 完成对象初始化，先进行默认初始化 age=0，age=null，再进行显式的初始化，age=90，最后进行构造器的初始化age=20，name=xiaoming
4. 对象在堆中的地址，返回给p（p是对象名，也可以理解成是对象的引用）



# this

概念：java虚拟机会给每个对象分配this，代表当前对象，哪个对象调用，this就表示当前对象

![i7qXb3cdwg4CxVp](https://xunfeng-images.oss-cn-shenzhen.aliyuncs.com/xfTyporaImages/i7qXb3cdwg4CxVp.png)

**用法**

1. this 关键字可以用来访问本类的属性、方法、构造器
2. this 用于区分当前类的属性和局部变量
3. 访问成员方法的语法：this.方法名(参数列表)
4. 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)
5. this 不能在类定义的外部使用，只能在类定义的方法中使用

# 访问修饰符(modifier)

概念：java提供四种访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限

1. 公开级别:用 public 修饰,对外公开 
2. 受保护级别:用 protected 修饰,对子类和同一个包中的类公开
3.  默认级别:没有修饰符号,向同一个包的类公开. 
4. 私有级别:用 private 修饰,只有类本身可以访问,不对外公开.



访问修饰符的访问范围

| 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| -------- | -------------- | ---- | ---- | ---- | ------ |
| 公开     | public         | T    | T    | T    | T      |
| 受保护   | protected      | T    | T    | T    | F      |
| 默认     | default        | T    | T    | F    | F      |
| 私有     | private        | T    | F    | F    | F      |

注意

1. 修饰符可以用来修饰类中的属性，成员方法以及类
2. 只有默认的和public才能修饰类（内部类除外），并且遵循上述访问权限的特点
3. 成员方法的访问规则和属性完全一样

# 面向对象编程三大特征

## 封装

### **概念**

封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用**抽象数据类型**将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。

### 作用

 对于封装而言，一个对象它所**封装的是自己的属性和方法**，所以它是不需要依赖其他对象就可以完成自己的操作

1. 良好的封装能够减少耦合。
2. 类内部的结构可以自由修改。
3. 可以对成员进行更精确的控制。
4. 隐藏信息，实现细节。

### 注意

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

## 继承

### 概念

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。

继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。

    实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”。
### 作用

**优点**

1. 减少代码量，能很好的提高复用率。
2. 代码的扩展性和维护性提高了
3. 使类与类之间存在继承关系，是实现多态操作的前提。

**缺点**

1. 父类变，子类就必须变。
2. 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。
3. 继承是一种强耦合关系。

### 注意

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问
2. 子类必须调用父类的构造器， 完成父类的初始化
3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无 参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)
5. super 在使用时，必须放在构造器第一行(super 只能在构造器中使用) 
6.  super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
7. java 所有类都是 Object 类的子类, Object 是所有类的基类
8. 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)
9. 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 
10. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系



### 构造器

通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的---构造器。对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用super()即可。

    构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。
    
    但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。
    
    对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。

对于继承而言，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。


### protected关键字

private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。

    对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。
### 向上转型



### 内存布局

```java
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();//内存的布局
        //?-> 这时请大家注意，要按照查找关系来返回信息
        //(1) 首先看子类是否有该属性
        //(2) 如果子类有这个属性，并且可以访问，则返回信息
        //(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
        //(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... System.out.println(son.name);//返回就是大头儿子
        //System.out.println(son.age);//返回的就是 39
        //System.out.println(son.getAge());//返回的就是 39
        System.out.println(son.hobby);//返回的就是旅游
        System.out.println(son.name);
    }
}

class GrandPa { //爷类
    String name = "大头爷爷";
    String hobby = "旅游";
}

class Father extends GrandPa {//父类
    String name = "大头爸爸";
    private int age = 39;

    public int getAge() {
        return age;
    }
}

class Son extends Father { //子类
    String name = "大头儿子";
}
```

![UNqsGtg2Zn9SXcY](https://xunfeng-images.oss-cn-shenzhen.aliyuncs.com/xfTyporaImages/UNqsGtg2Zn9SXcY.png)

## 多态

### 概念

基本介绍：方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

​	所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，**即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定**。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

所以对于多态我们可以总结如下：

​	指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。

    对于面向对象而言，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。
### 实现条件

在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。

Java实现多态有三个必要条件：继承、重写、向上转型。

    继承：在多态中必须存在有继承关系的子类和父类。
    
    重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
    
    向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。
    
    只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。
    
    对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。
### 多态的具体体现

方法的多态： 重写和重载体现多态

对象的多态

1. 一个对象的编译类型和运行类型可以不一致
2. 编译类型在定义对象时，就确定了，不能改变
3. 运行类型是可以变化的
4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边
   Animal animal = new Dog();   //Dog类继承Animal类，animal编译类型是Animal，运行类型是Dog
   animal = new Cat(); // animal的运行类型变成了Cat，编译类型仍然是Animal

### 多态的实现新式

**基于继承实现的多态**
    基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。

    基于继承实现的多态可以总结如下：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。
    
    如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。

**基于接口实现的多态**
    继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。

    在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。
    
    继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。
### 注意和细节

多态的前提是：两个类存在继承关系

**多态的向上转型**

1. 本质：父类的引用指向了子类的对象
2. 语法：父类类型 引用名 = new 子类类型();
3. 特点：编译类型看左边，运行类型看右边
   可以调用父类中所有成员（需遵循访问权限）
   不能调用子类中的特有成员 因为在编译阶段，能调用哪些成员，是由编译类型来决定的
   最终运行效果看子类的具体实现 即调用方法时，从子类（运行类型）开始查找方法
4. 属性的值看编译类型，例如2中父类类型 引用名 = new 子类类型();若父类类型和子类类型中含有相同的属性，则调用的为父类类型的属性

**多态的向下转型**

1. 语法：子类类型 引用名 = （子类类型）父类引用();
2. 只能强转父类的引用，不能强转父类的对象
3. 要求父类的引用必须指向的是当前目标类型的对象
4. 当向下转型后，可以调用子类类型中的所有成员

instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型

### 动态绑定机制

java的动态绑定机制

1. 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
2. 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

```java
public class DynamicBinding {
    public static void main(String[] args) {
//a 的编译类型 A, 运行类型 B
        A a = new B();//向上转型
        System.out.println(a.sum());//?40 -> 30
        System.out.println(a.sum1());//?30-> 20
    }
}
class A {//父类
    public int i = 10;
    //动态绑定机制:
    public int sum() {//父类 sum()
        return getI() + 10;//20 + 10
    }
    public int sum1() {//父类 sum1()
        return i + 10;//10 + 10
    }
    public int getI() {//父类 getI
        return i;
    }
}
class B extends A {//子类
    public int i = 20;
    // public int sum() {
// return i + 20;
// }
    public int getI() {//子类 getI()
        return i;
    }
// public int sum1() {
// return i + 10;
// }
}
```







# super关键字

概念：super 代表父类的引用，用于访问父类的属性、方法、构造器

基本语法：

1. 访问父类的属性，但不能访问父类的private属性。super.属性名
2. 访问父类的方法，但不能访问父类的private方法。super.方法名(参数列表)
3. 访问父类的构造器。super(参数列表)，只能放在构造器第一句，只能出现一句
4. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则

super和this的比较



![wzQbvJsF8hVaciP](https://xunfeng-images.oss-cn-shenzhen.aliyuncs.com/xfTyporaImages/wzQbvJsF8hVaciP.png)

# 方法重写/覆盖(override)

**概念**

简单来说，方法覆盖就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法

**注意**

子类的方法的形参列表，方法名称，要和父类方法的形参列表，方法名称完全一样

子列方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，例如 父类返回类型为Object，子类方法返回类型为String 

子类方法不能缩小父类方法的访问权限 public>protected>默认>private

**方法重写和方法重载比较**

| 名称           | 发送范围 | 方法名   | 形参列表                         | 返回类型                                                 | 修饰符                             |
| -------------- | -------- | -------- | -------------------------------- | -------------------------------------------------------- | ---------------------------------- |
| 重载(overload) | 本类     | 必须一样 | 类型，个数或者顺序至少有一个不同 | 无要求                                                   | 无要求                             |
| 重写(override) | 父子类   | 必须一样 | 相同                             | 子类重写的方法返回的类型和父类返回类型一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围 |

# Object类详解

## == 和equals比较

==是一个比较运算符

1. 既可以判断基本类型，又可以判断引用类型
2. 如果判断基本类型，判断的是值是否相等
3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象
4. equals：是Object类中的方法，只能判断引用类型
5. 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer，String

重写equals实例

```java
//判断两个 Person 对象的内容是否相等，
//如果两个 Person 对象的各个属性值都一样，则返回 true，反之 false
class Person{ //extends Object
    private String name;
    private int age;
    private char gender;
    //重写 Object 的 equals 方法
    @Override
    public boolean equals(Object obj) {
//判断如果比较的两个对象是同一个对象，则直接返回 true
        if(this == obj) {
            return true;
        }
//类型判断
        if(obj instanceof Person) {//是 Person，我们才比
            //进行 向下转型, 因为我需要得到 obj 的 各个属性
            Person p = (Person)obj;
            return this.name.equals(p.name) && this.age == p.age && this.gender == p.gender;
        }
//如果不是 Person ，则直接返回 false
        return false;
    }
}
```

## hashCode方法

1. 提高具有哈希结构的容器的效率！
2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！
3. 两个引用，如果指向的是不同对象，则哈希值是不一样的
4.  哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址案例演示[HashCode_.java]: obj.hashCode() [测试：A obj1 = new A(); A obj2 = new A(); A obj3 = obj1] 
5.  后面在集合中 hashCode 如果需要的话，也会重写

## toString方法

**基本介绍**

默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】 

子类往往重写 toString 方法，用于返回对象的属性信息

重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式

当直接输出一个对象时，toString 方法会被默认的调用, 比如System.out.println(monster)； 就会默认调用 monster.toString()

## finalize方法

1. 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作
2.  什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。
3. 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制，测 试：Car [name] 

提示： 我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试.

```java
//演示 Finalize 的用法
public class Finalize_ {
    public static void main(String[] args) {
        Car bmw = new Car("宝马");
//这时 car 对象就是一个垃圾,垃圾回收器就会回收(销毁)对象, 在销毁对象前，会调用该对象的 finalize 方法
//,程序员就可以在 finalize 中，写自己的业务逻辑代码(比如释放资源：数据库连接,或者打开文件..)
//,如果程序员不重写 finalize,那么就会调用 Object 类的 finalize, 即默认处理
//,如果程序员重写了 finalize, 就可以实现自己的逻辑
        bmw = null;
        System.gc();//主动调用垃圾回收器
        System.out.println("程序退出了....");
    }
}
class Car {
    private String name;
    //属性, 资源。。
    public Car(String name) {
        this.name = name;
    }
    //重写 finalize
    @Override
    protected void finalize() throws Throwable {
        System.out.println("我们销毁 汽车" + name );
        System.out.println("释放了某些资源...");
    }
}
```

