# 线性表 - 数组和矩阵

> 数组是一种连续存储线性结构，元素类型相同，大小相等，数组是多维的，通过使用整型索引值来访问他们的元素，数组尺寸不能改变。@pdai

[知识点]()[数组与矩阵相关题目]()

## 知识点

数组的优点:

- 存取速度快

数组的缺点:

- 事先必须知道数组的长度
- 插入删除元素很慢
- 空间通常是有限制的
- 需要大块连续的内存块
- 插入删除元素的效率很低

JDK中关于ArrayList的实现，请参考:

[《Java - ArrayList 源码解析》]()

## 数组与矩阵相关题目

### [2103. 环和杆](https://leetcode.cn/problems/rings-and-rods/)

总计有 `n` 个环，环的颜色可以是红、绿、蓝中的一种。这些环分别穿在 10 根编号为 `0` 到 `9` 的杆上。

给你一个长度为 `2n` 的字符串 `rings` ，表示这 `n` 个环在杆上的分布。`rings` 中每两个字符形成一个 **颜色位置对** ，用于描述每个环：

- 第 `i` 对中的 **第一个** 字符表示第 `i` 个环的 **颜色**（`'R'`、`'G'`、`'B'`）。
- 第 `i` 对中的 **第二个** 字符表示第 `i` 个环的 **位置**，也就是位于哪根杆上（`'0'` 到 `'9'`）。

例如，`"R3G2B1"` 表示：共有 `n == 3` 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。

找出所有集齐 **全部三种颜色** 环的杆，并返回这种杆的数量。

**解法一**：将杆作为横坐标，三种颜色作为纵坐标，则构成二维数组，若杆1红则该位置置一，统计三个位置为1的杆的数量

```java
class Solution {
    private static int NUM = 10;
    public int countPoints(String rings) {
        int length = rings.length();
        int[] state = new int[NUM];

        for(int i =0; i<length;i+=2){
            char val = rings.charAt(i);
            int index = rings.charAt(i+1) - '0';
            if(val == 'R'){
                state[index] |= 1;
            } else if(val == 'G'){
                state[index]|= 2;
            } else{
                state[index]|=4;
            }
        }
        int sum =0;
        for(int i=0;i<NUM;i++){
            sum += state[i] ==7?1:0;
        }
        return sum;

    }
}
```

**解法二**：将RGB三种颜色用二进制表示，则111=7表示拥有三种颜色

```java
class Solution {
    private static int NUM = 10;
    public int countPoints(String rings) {
        int length = rings.length();
        int[] state = new int[NUM];

        for(int i =0; i<length;i+=2){
            char val = rings.charAt(i);
            int index = rings.charAt(i+1) - '0';
            if(val == 'R'){
                // 或操作
                state[index] |= 1;
            } else if(val == 'G'){
                state[index]|= 2;
            } else{
                state[index]|=4;
            }
        }
        int sum =0;
        for(int i=0;i<NUM;i++){
            sum += state[i] ==7?1:0;
        }
        return sum;

    }
}
```

# 树 - 基础和Overview

> 树在数据结构中至关重要，这里展示树的整体知识体系结构和几种常见树类型。

![img](https://xunfeng-images.oss-cn-shenzhen.aliyuncs.com/xfTyporaImages/alg-tree-0.png)

## 知识点

#### 遍历

## 二叉树相关题目

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

给定一个二叉树：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

解法一：二叉树层序遍历

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {

        if(root == null){
            return null;
        }
        Queue<Node> queue = new ArrayDeque<>();
        queue.add(root);
        Node before = null;
        while (!queue.isEmpty()) {
            int n = queue.size();
            for (int i = 0; i < n; i++) {
                Node node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                if (i != 0) {
                    before.next = node;
                }
                before = node;
            }
        }
        return root;
    }
}
```

